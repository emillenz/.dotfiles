#+title:  doom emacs config
#+author: emil lenz
#+email:  emillenz@protonmail.com
#+date:   2022-11-01
#+info:   heavily opinionated config, with a principle-focused approach on: consistency, quality, efficiency & extensibility.

#+property: header-args:elisp tangle config.el :comments link :results silent
#+macro: src-len (eval (save-excursion (find-file doom-module-config-file) (count-lines (point-min) (point-max))))

* about this config
- a total of {{{src-len}}} LOC.
- for debugging our configuration, start emacs with: ~emacs --debug-init~ to get a backtrace.  when debuggin lisp code, enable ~toggle-debug-on-error~ and eval the code.
- read up on and adhere to [[https://github.com/bbatsov/emacs-lisp-style-guide][emacs-lisp style guide]].
- user defined global functions and variables are prefixed with ~u-~ (~user~) to distinguish them from emacs/library ones.
- lazyload packages using ~after!~.  this keeps emacs efficent, since it now only loads the settings & packages when they are actually needed (no emacs bankruptcy).
- i believe that customizations are personal and should not be blindly copied.  Everyone should carefully consider each customizable setting they hear about and decide for themselves whether they like it or not.  Non-trivial customizations that include Lisp code should be fully understood before they are accepted, rejected, or amended to personal taste.  (read the manual)
  - be encouraged to master the tool that we are using.  this means thoroughly reading the complete documentation, keymaps for the tools we are using (eg. vertico, evil-mode, magit, leader-mode).
  - try to first fundamentally understand & master the functionality the tool offers.  then we may assess and see if a extension really provides value to us, or if that functionality is already included.
- use ~use-package!~ for configuring packages added via ~package!~ in ~./packages.el~
- to debug, start emacs with ~emacs --debug-init~ and use ~emacs --no-init-file~ to fix the errors.
- to see how you may configure a package, ~customize-group~ gives a good overview of available options (but never use it to configure anything, do in ~config.org~)
- we shall never use ~:ex~ commands and instead use the native ~M-x~ and ~C-x / C-c~ bindings that emacs provides for a more consistent experience.
- viper mode :: use it if it's not feasible to install the full doom-config (eg. using emacs on another computer).
  - viper provides 80% of evil-mode's ergonomics with emacs extensibility and power.
- if you remove a package, search this entire config for entries to also remove, since some configuration entries are centralized under different headings (eg. ~indentation~).
- we always make use of threading operators: ~->>~, since this greatly enhances readability.


* preface
** why emacs
#+begin_quote
Today, many aspects of daily computer usage are split between different applications which act like islands, but this often doesn’t mirror how we actually use our computers.  Emacs, if one goes down the rabbit hole, can give users the power to bridge this gap into a visually and functionally consistent environment.

Professional, minimalist tools like Emacs have a high learning curve and require thought and time to initially set up.  But once things are working and customized they will work for years at a stretch without needing to fiddle with the nobs.  And once mastered you can eliminate the "modern" GUI bits -- tool bars, menus, scrollbars and fancy animations and the like and what is left is about as clean an interface as you can get stripping everything down to the bare metal where it gets out of your way and provides the most streamlined workflow.  The difference is that something like emacs is a longterm investment, it requires you to get over the high entry barrier but then never annoys you with a more elongated, bloated workflow that in other, more beginner friendly applications is the norm and cannot be changed away from.

The saying, "give 'em enough rope, and they'll likely hang themselves," holds true.  Emacs provides the rope if you are not careful.
--- anonymous
#+end_quote

emacs is one of the most incredible piece of software ever made:
- purely keyboard driven.
- everything is text and can be modified.
- enables one to complete tasks with a consistent, standard set of keybindings, gui and editing methods - learn once, use everywhere
- compressing the stages of a project - a more centralised workflow can progress with greater ease
- integration between tasks previously relegated to different applications, but with a common subject - e.g.  linking to an email in a to-do list etc
- emacs can be thought of as a platform within which various elements of our workflow may settle, while being able to interlink them interactively.
- reduced context-switching, many tools in one connected, coherent, interwoven keyboard-driven interface.  this integration is very efficient and consistent, since now any function can be reused in all tools (eg.  fuzzy finding, and doesn't have to be implemented in each separate program itself).  it greatly reduces the mental overhead needed to customize and extend the tools, since the context and language is always the same.  since these tools are text-centric, they align withthe single focus, no multitasking buffer wokflow philosophy.
  - editor
    - technical documents :: latex & org
    - academic papers
    - code
    - notes
    - journaling
  - programming tools
    - git interface :: magit
    - manpages
    - diff
    - debugger
  - agenda
  - emailclient
  - todo-management :: org mode
  - filemanager :: dired fast interactive text-based file manger
  - manpager
  - file/dir navigation & management: find-file, fuzzy-find, (book)marks, dired
    - the most efficient workflow for finding, opening and editing files on the os that i have ever developed.

*** org mode
- the most elegant markup language, all the while keeping the syntax opinionated and simple with only one way to do it (=> looking at you: markdown with your weird spacing rules and arcane markup for links/quotes).
- one to rule them all, create websites, tables, journals, todolists, calendars and programs, all with the same consistent elegant and formatted syntax.
- automate making entries into files and databases at specific places.
- completely integrated into the editor (think: finding/filtering headlines, notes, tasks..)
- the best support for literate programming covering every language (looking at you: jupyter..)

*** emacs everywhere
use emacs everywhere for anytime we are using a prompt that requires more than few simple keywords.  eg. chatgpt query, writing a email.  execute emacs-everywhere from i3 (via keybinding) once inside the textfield (or highlighting all text to take over to emacs)

*** downsides
emacs sucks at graphical stuff, hence we use external programs to display pdfs and media.

** emacs as the computing evironment
- extend emacs by writing custom functions for things that are done repetitivly (moving files, manipulating text...) instead of writing shell aliases / shellscripts
  + more extensible and in a proper language
  + write shell-scripts (purely) for launching programs & processes.
- all programming, writing, fileopening, viewing, navigating is done inside emacs (do not leave the environment), because this makes for a consistent and coherent workflow.  don't jump in and out of the commandline, lauching emacs instances, cd'ing around.
  - use inbuilt programs like magit & diff for more speed interactivity and ergonomics than doing it with git command aliases on the command-line.

** shell: using emacs instead of dedicated terminal
we might be tempted to use a terminal with tmux, zsh/fish, fzf, fancy prompts, bat, exa, and pages filled with git aliases configured.  this results in great complexities and inconsistencies (trying to get the same keybindings, theme etc.) in the shell and editor.  instead shun all these features and focus on emacs.  using emacs yields consistency in bindings between the shell and the editor.  no more juggling tmux and the system clipboard when trying to yank/paste text.  no installing tons of shell-plugins to get better vim emulation in the shell (looking at you *zsh*).  we can seamlessly open and switch between man/help/tldr pages while using the shell.  we can navigate & filter (~occur~, etc...) the shell output (instead of using some hacked up, incomplete and inconsistent vim emulation like tmux).  instead of using cd etc. we can freely use all of emacs navigational capabilities (projectile, recentfiles...) (instead of having to install fzf and other crutches).
our syntax highlighting (including help output etc) is directly inherited from our emacs-theme.
using emacs for shells also has the benefit that we can seamlessly create a buffer to script in as soon as we're doing more than a simple oneliner, then either evaluating that buffer or regions to the shell.

*** workflow
use simple minbuffer based ~async-shell-command~'s in emacs, if that doesn't suffice, open: ~shell~.  especially when programming, start REPL's and interactive environments from within emacs (terminal emulation) in order to have a seamless integration and navigation between running commands in the shell and programmning.  this has the benefit that of being able to navigate command output like a normal buffer and use the full power of emacs for the prompt editing.

the only reason for us to ever use a terminal is if we need to use a TUI.  (for processes that should run independent of emacs, use disown)

* required libraries for config
- modern & functional lisp.  (provides many concepts from clojure, etc. such as destructuring in lambdas, let's, etc.)
#+begin_src elisp
(require 'dash)
#+end_src

* user
#+begin_src elisp
(setq user-full-name "emil lenz"
      user-mail-address "emillenz@protonmail.com")
#+end_src

* global options
#+begin_src elisp
(let ((width 100))
  (setq fill-column width
        async-shell-command-width width
        visual-fill-column-width width))

(global-visual-fill-column-mode)
(global-visual-line-mode)
#+end_src

#+begin_src elisp
(setq initial-scratch-message nil
      delete-by-moving-to-trash t
       ;; save bookmarks in config dir (to preserve inbetween newinstalls)
      bookmark-default-file "~/.config/doom/bookmarks"
      auto-save-default t
      confirm-kill-emacs nil

      ;; for looking up docs/help while in minibuffer
      enable-recursive-minibuffers t)

(save-place-mode)

(global-subword-mode)

(add-hook! 'prog-mode-hook #'rainbow-delimiters-mode)

(setq global-auto-revert-non-file-buffers t)
(global-auto-revert-mode)
#+end_src

- HACK :: must disable, since it displays the ~flycheck~ inline warnings/errors incorrectly.
#+begin_src elisp
(add-hook! 'prog-mode-hook
  (visual-fill-column-mode -1))
#+end_src

- HACK :: we don't use macOS, and ~+default/man-or-woman~ doesn't invoke ~man~ correctly
#+begin_src elisp
(advice-add '+default/man-or-woman :override #'man)
#+end_src

* ui
** modus-theme
#+begin_src elisp
(use-package! modus-themes
  :config
  (setq modus-themes-italic-constructs t
        modus-themes-bold-constructs t
        modus-themes-common-palette-overrides `((fg-region unspecified) ;; don't grey out syntax highlighting in active region
                                                (fg-heading-1 fg-heading-0))) ;; colorize (before: black)
  ;; list of customizeable faces: `(helpful-variable 'modus-themes-faces)`
  (custom-set-faces!
    '(org-list-dt :inherit modus-themes-heading-1)
    `(org-block-begin-line :foreground ,(modus-themes-get-color-value 'prose-metadata))
    '(org-quote :slant italic)

    '(comint-highlight-prompt :weight bold))

  (setq doom-theme 'modus-operandi))
#+end_src

the ~org-block~ background is different (dimmed) from ~bg-main~ in order to distinguish blocks clearly.  ~whitespace-tab~ uses ~bg-main~ by default, but we want same dimmed bg color as all text.
#+begin_src elisp
(add-hook! 'org-mode-hook
  (face-remap-add-relative 'whitespace-tab 'org-block))
#+end_src

** font
- same font & size set to same as system-wide (browser, gtk, terminal, ...).
- variable-pitch-mode :: only for prose i sometimes use a serif font to become more immersed in the reading experience.  like the modeline & minibuffer, we use the default font for line-numbers (by default not the case).
- font-size :: don't use manual font-size increasing, instead just use ~doom-big-font-mode~ (eg. for presentation purposes)
- ~simple-html-rendering~ (~shr~) ::  should always use the universally applicable default font since we can't presume the content to be displayed with it.  (it is used for eg. ~devdocs~)
#+begin_src elisp
(setq doom-font (font-spec :family "Iosevka Comfy" :size 13))
(setq doom-variable-pitch-font (font-spec :family "Noto Serif" :size 13))

(set-face-attribute 'line-number nil :inherit 'fixed)

(after! shr
  (setq shr-use-fonts nil))
#+end_src

** modeline
- no overlapping funcionality (time & date is on my physical wrist watch, don't need it in any program (also not wm)).
- very minimal, only displaying what's needed (using (:modeline +light))
#+begin_src elisp
(setq display-battery-mode nil
      display-time-mode nil
      +modeline-height 8
      +modeline-bar-width nil) ;; hide unicode sugar
#+end_src

** display buffers
- single maximized buffer workflow :: we explicitly never use more than a single window (we don't split a window) in the frame, since we can only ever focus on a single thing anyways, and thus in the meantime other windows would clutter the screen distractingly.  additionally using multiple windows introduces additional navigational overhead first having to go to the correct window before using ~switch-to-buffer~, ~global-marks~ etc. managing windows and placing them correctly is complex and inconsistent, some windows recieve focus, other's don't, some buffer's create a split, completely changing window layout, others don't.  instead of using windows, we must become really efficient at navigating between buffers using ~switch-to-buffer~, ~evil-switch-to-windows-last-buffer~, and ~global-marks~.  it is more efficiet to just change the buffer in the current window, instead of getting disrupted by the newly opened window.
- only horizontal split :: since emacs sometimes creates splits in special views (eg. magit, ediff) or for displaying additional information (lsp-help...), and thus we must handle them to consistently split below and never side-by-side, since due to the wm, our emacs window is in full height but has a constrained width, perfectly sized for displaying source-code / technical documents.
- minibuffers :: at the bottom, consistent with ~minibuffer-prompt~, ~whichkey~, etc.  use ~doom/window-enlargen~ as needed.

#+begin_src elisp
(setq display-buffer-base-action '(display-buffer-same-window)
      switch-to-buffer-obey-display-actions t
      display-buffer-alist
      `((,(rx (seq "*"
		   (or "transient"
                       (seq "Org " (or "Select" "todo"))
                       "Agenda Commands"
                       "doom eval"
                       "Backtrace"
                       "lsp-help"
		       (seq (opt "Async ") "Shell Command"))))
         display-buffer-at-bottom
         (window-height . fit-window-to-buffer))

	("." display-buffer-same-window)))
#+end_src

some modes implement their own buffer popup system or make use of ~switch-to-buffer-other-window~ we make them obey/consitent with ~display-buffer-alist~'s behaviour.
#+begin_src elisp
(after! org
  (setq org-src-window-setup 'plain ;; use display-buffer setting
        org-agenda-window-setup 'current-window))

(after! man
  (setq Man-notify-method 'pushy))

(advice-add #'switch-to-buffer-other-window :override #'switch-to-buffer)

(after! cider
  (setq cider-auto-select-error-buffer nil ;; don't annoy us
	cider-inspector-auto-select-buffer nil))

(after! magit
  (setq magit-commit-diff-inhibit-same-window t
        +magit-open-windows-in-direction 'down))
#+end_src

** line numbers
- we make extensive use of relative line motions (eg: ~12dj~ etc.).
#+begin_src elisp
(setq display-line-numbers-type 'relative)
#+end_src

** cursor
i like the minimalist, unambiguous look of a block cursor (mode switching is done subconscious anyways).
#+begin_src elisp
(after! evil
  (setq evil-insert-state-cursor evil-normal-state-cursor))
#+end_src

** formatting
don't format my file automatically on-save.  instead format by calling it manually.  sometimes a file needs manual alignment that a formatter destroys.  our old ass computer is to weak to be able to run a format each time the file is saved.

** indentation
*** rationale
a useful time for a quote from the linux kernel programming standards [1] - exactly the first item in fact:

#+begin_quote
Tabs are 8 characters, and thus indentations are also 8 characters.  There are heretic movements that try to make indentations 4 (or even 2!) characters deep, and that is akin to trying to define the value of PI to be 3.  If you need more than 4 levels of indentation within a function, you’re screwed anyway, and should fix your program.
--- Linus Torvalds
#+end_quote

the 8-wide tab indent cannot exist in isolation.  it has to be coupled with a right-hand side limit of 80 columns.  otherwise, you could just indent yourself off to infinity and there would be no consequences.  an 80 column limit forces you to keep your code within reasonable limits.

the whole idea behind indentation is to clearly define where a block of control starts and ends.  this is the same philosophy applied in ~modus-theme~, where we clearly want to separate elements and enhace legibility & accessibility.  especially when you’ve been looking at your screen for 20 straight hours, you’ll find it a lot easier to see how the indentation works if you have large indentations.  you can look at a function definition from afar and tell easily where it begins & ends even though you cannot read the actual code.  it facilitates reading through a codebase in a more tree-like fashion.

every level of indentation represents a piece of program state the reader has to keep in their head to understand a function.  “in this line, i know line points to the nth line as long as x is not true, but y > z.” 8-character indentations, internal spacing, and the 80-column rule effectively limits you to 4 levels of indentation in a function.  this effectively limits the internal complexity of any give function, which makes the code easier to understand and debug!  so the underlying functionality remains minimal and concise.

in short, 8-wide indents make things easier to read, and have the added benefit of warning you when you’re nesting your functions too deep.  heed that warning.

- consistency :: the only reliable, repeatable, transportable way to ensure that indentation remains consistent across programming languages is to indent code using only tabs.
- tabs have the semantic meaning of indentation.  tabs always align to the same column, no matter from where inserted in the column.
- tabs allow impaired users to display indentation in the way they deem most ergonomic (accessibility!).
- TODO :: always configure your language formatters (eg. clang-format) to use tabs for indentation.
#+begin_src elisp
(defvar u/global-indent-width 8)

(setq-default indent-tabs-mode t
              tab-width u/global-indent-width
              standard-indent u/global-indent-width
              evil-indent-convert-tabs t
              evil-shift-width u/global-indent-width
              org-indent-indentation-per-level u/global-indent-width)

(setq c-default-style "linux")

(after! sh-script
  sh-basic-offset u/global-indent-width)
#+end_src

* evil-mode
- evil comes with powerful additions and bindings that are to be discovered: [[~/.config/emacs/modules/editor/evil/README.org::* TODO Usage][evil readme]].  familiarize and harness their power.
- evil-magic 'nomagic :: statistically its more sensible to incsearch without regex (if we need it, use ~\m~ as a prefix in search string to enable regex.

#+begin_src elisp
(after! evil
#+end_src

#+begin_src elisp
(evil-surround-mode)
(setq evil-want-fine-undo nil
      evil-magic 'very-nomagic
      evil-ex-substitute-global t
      evil-want-C-i-jump t
      evil-want-C-h-delete t
      evil-want-minibuffer t ;; don't loose our powers in the minibuffer
      evil-org-use-additional-insert nil)

(defadvice! u/preserve-point (fn &rest args)
  :around '(anzu-query-replace-regexp
            query-replace-regexp
            +format:region)
  (save-excursion
    (apply fn args)))

;; FIXME :: `+fold/previous` disabled, since it crashes emacs. (don't call it by accident via binding)
(advice-add '+fold/previous :override #'ignore)
#+end_src

- jumplist is for functions that jump out of screen
- don't populate jumplist with fuctions that are executed repeatedly (ex: forward-paragraph)
#+begin_src elisp
(dolist (cmd '(flycheck-next-error
		 flycheck-previous-error
		 +lookup/definition
		 +lookup/references
		 +lookup/implementations
		 +default/search-buffer
		 consult-imenu))
  (evil-add-command-properties cmd :jump t))

(dolist (cmd '(evil-backward-section-begin
		 evil-forward-section-begin
		 evil-jump-item
		 evil-backward-paragraph
		 evil-forward-paragraph
		 evil-forward-section-end))
  (evil-remove-command-properties cmd :jump))
#+end_src

#+begin_src elisp
(defadvice! u/update-last-macro-register (fn &rest args)
  "when a macro was recorded and `evil-last-register' is still `nil' (no macro was executed yet),
  set it to the just recorded macro.

this is the sane default behaviour for 99% of the time: record a quick macro with 'qq' and
immediately call it with '@@', instead of getting an error, getting annoyed and having to retype
'@q' (the exact key) for the first time and then only after that we may call '@@'."
  :after #'evil-record-macro
  (when (not evil-last-register)
    (setq-local evil-last-register evil-last-recorded-register)))
#+end_src

#+begin_src elisp
)
#+end_src

* global keybindings
- ~helpful-key~ and are crucial to understanding what our tools can do for us (ex: magit, dired, org-mode)
- i recommend to lookup the variable: ~M-x helpful-variable <X-mode-map>~ to get an overview of the available bindings for that mode.  find out the mode with: ~M-x describe-mode~
- always keep on exploring, learning new, efficient keybindings and break old routines for newer, more effcient one's after evaluating wether they are faster or not.
- localleader :: [[kbd:][:leader m]] mnemonic for ~major-mode~.  additionally it can be pressed in rapid succession ergonomically (at least on ~dvorak & querty~).
- generally [[kbd:][ctrl]] bindings in vim are either for insert mode or navigation (eg. [[kbd:][C-u/d/j/k/o]]).
- make sure to use toplever leader mappings: [[kbd:][SPC ,]] ~consult-buffer~, [[kbd:][SPC SPC]] ~projectile-find-file~. since they are some of the most called functions.
- to access a help menu (eg. view bindings) while in insert mode, use [[kbd:][F1]].

** leaderkey
#+begin_src elisp
(setq doom-leader-key "SPC"
      doom-localleader-key "SPC m")

(map! :leader
      "'" #'consult-bookmark

      (:prefix "h"
               "w" #'tldr)
      (:prefix "s"
               "k" #'devdocs-lookup
               "t" #'dictionary-search)
      (:prefix "f"
               "f" #'+vertico/consult-fd-or-find)
      (:prefix "t"
	       "a" #'toggle-text-mode-auto-fill)
      (:prefix "c"
               "r" #'lsp-rename
               (:prefix "'"
                        "t" #'org-babel-tangle
                        "T" #'org-babel-detangle))
      (:prefix "n"
               "g" #'org-capture-goto-last-stored))
#+end_src

** completion & minibuffer
- history using normal-mode :: [[kbd:][j, k, /, RET]]  for evil-consistency.  ~evil~ expects us to use unergonomic/inaccessible [[kbd:][up, down]] by default.  (for ~comint-mode~ we use [[kbd:][ctrl-n/p]] since [[kbd:][j, k]] navigate the buffer).

#+begin_src elisp
(->> (list minibuffer-mode-map
           evil-ex-search-keymap)
     (mapc (lambda (mode-map)
             (map! :map mode-map
                   :n "j" #'next-line-or-history-element
                   :n "k" #'previous-line-or-history-element
                   :n "/" #'previous-matching-history-element

		   :n "RET" #'exit-minibuffer)))) ;; dwim

(map! :map vertico-map :after vertico
      :n "RET" #'vertico-exit ;; dwim

      ;; cycle cadidates (don't complete)
      :i "C-n" #'next-line
      :i "C-p" #'previous-line

      ;; smarter C-w
      :im "C-w" #'vertico-directory-delete-word

      :im "C-d" #'consult-dir
      :im "C-f" #'consult-dir-jump-file)

(map! :map comint-mode-map :after comint
      :i "C-r" #'comint-history-isearch-backward-regexp)

;; not defined :(
(map! :map cider-repl-mode-map :after cider-repl
      ;; consistent with comint, magit, org,....
      :n "C-j" #'cider-repl-next-prompt
      :n "C-k" #'cider-repl-previous-prompt

      :n "C-n" #'cider-repl-next-input
      :n "C-p" #'cider-repl-previous-input
      :i "C-r" #'cider-repl-previous-matching-input)
#+end_src

in search/replace minibuffers we want C-p to work as in evil buffer's: to expand matches of the buffer.  C-n is still mapped to 'minibuffer-complete'.  this allows us to eg. quickly replace the symbol at 'point'.
#+begin_src elisp
;; HACK :: '(1) since evil-complete-previous-func expects an arg.
(setq evil-complete-previous-minibuffer-func
      #'(lambda () (apply evil-complete-previous-func '(1))))
#+end_src

** editing
- goal :: make vim's bindings even more mnemonic/sane/sensible/efficient and improve consistency of implementation.
- fundamentals :: we don't change fundamental bindings of vi(m), we improve on them, as to retain muscle memory and consistency in other applications (eg. ~viper-mode~, vim emulations).
- useless defaults :: we map to the statistically most frequently used/basic-navigational commands (since they are valuable top-level bindings). (see: [[http://xahlee.info/emacs/emacs/command-frequency.html][emacs command frequency statistics]]).
- [[kbd:][L]] :: inverse of: [[kbd:][L]], ~electric-newline-and-indent~.  this is really convenient to eg. split function arguments onto newlines.
- [[kbd:][_]] :: default mapping is useless (use [[kbd:][^]]).  commonly used (but unergonomic) [[kbd:]["_d]] to kill into the ~null-register~.  use when you don't want to preserve your register.
- [[kbd:][+/-]] :: more sensible & ergonomic than [[kbd:][C-x/a]] [[kbd:][+/-]] in vim is useless anyways.
- [[kbd:][TAB]] :: we frequently alternate between 2 bufers in rapid succession (especially since we don't use splits), and we follow the OS consistent binding.  (evil's [[kbd:][C-6]] is terribly unergonomic).
  - in modes like ~org~, ~magit~, where [[kbd:][TAB]] is normally used for folding, we should by using the evil fold-prefix: [[kbd:][z]].  this is more efficient and precise than cycling the fold levels with ~org-cycle~.
- HACK :: map [[kbd:][C-h]] to [[kbd:][backspace]] consistently (some modes don't respect ~evil-want-C-h-delete~).
#+begin_src elisp
(map! :after evil
      :n "L" #'newline-and-indent
      :n "_" (cmd! (evil-use-register ?_)
                   (call-interactively #'evil-delete))

      :n "\\" (cmd! (save-excursion
                      (->> '(mark-paragraph
                             evil-indent)
                           (mapc #'call-interactively))))

      :n ","  #'basic-save-buffer

      :n "+"  #'evil-numbers/inc-at-pt
      :n "-"  #'evil-numbers/dec-at-pt
      :n "g+" #'evil-numbers/inc-at-pt-incremental
      :n "g-" #'evil-numbers/dec-at-pt-incremental)

(map! :map 'override
       ;; HACK :: must be <tab> not TAB to properly override
      :nm "<tab>" #'evil-switch-to-windows-last-buffer
      :nm "Z" #'kill-current-buffer
      :nm "v" #'find-file
      :nm "V" #'consult-buffer)

(define-key! [remap +org/toggle-fold] #'org-cycle)
(define-key! key-translation-map "C-h" "DEL")
#+end_src

- [[kbd:][C-j/k]] :: navigate by sections.  these bindings are implemented in ~magit~, ~info-mode~, ~man~, ~org-mode~.
- we often use long lines in prose with ~visual-fill-column-mode~.
- [[kbd:][gj, gk]] :: respect evil's fundamentally neccessary bindings.
#+begin_src elisp
(map! :map evil-org-mode-map :after evil-org
      :n "gj" #'evil-next-visual-line
      :n "gk" #'evil-previous-visual-line

      :n "C-j" #'org-next-visible-heading
      :n "C-k" #'org-previous-visible-heading)
#+end_src

- close popup window (eg. ~*lsp-help*~) from the main window with [[kbd:][escape]] in normal mode.  (ergonomic & fast)
- since we don't split we only need to occasionally switch window, and [[kbd:][C-w]] is just one keypress to many.  (additionally we also want to jump in/out of minbuffer window if it is active).
#+begin_src elisp
(add-hook! 'doom-escape-hook #'delete-other-windows)

(map! :after evil
      :nm "C-w" #'next-window-any-frame)
#+end_src

*** embrace emacs
- don't use vim's commandline: ~evil-ex~, instead just use emacs ~M-x~.  this introduces and additional layer of unneccessary complexity.  we use only the vim-motions, for all other things, emacs tools are more powerful.
  - :%s/ :: use emacs-native ~query-replace-regex~ instead, which is more interactive, powerful and flexible than vim's replacement.  it has undo, navigating matches, and can even transfor the match using arbitrary lisp code (see help: ~query-replace-regex~).
    - tip :: use ~C-r C-w/C-a~ to insert the inside-word/around-word under point in the main-buffer (vim feature).
  - :g :: use emacs ~reverse-region~, ~delete-lines~ and macros.
  - other commands such as ~:w~, ~:q~, ~:b~, ~:e~ etc. should be executed more ergonomically/efficiently by top-level keybindings (using [[kbd:][ctrl]]) anyways.
- [[kbd:][Q]] :: ~query-replace~ needs to be easily accessible (used all the time for renaming var's etc.) so it gets a top level binding and has directional forward/backward mapping like vim's: ~/?~.  (same as in ~viper-mode~) - [remap] :: use `remap' to replace function with enhanced ones that have the same functionality (thus keeping the binding's consistency).

#+begin_src elisp
(define-key! [remap evil-ex] #'execute-extended-command)

(map! :after evil
      :n "Q" #'u/query-replace-regexp-op)

(evil-define-operator u/query-replace-regexp-op (beg end type)
  "make (anzu)`query-replace-regexp' into an operator acting only on defined region."
  :repeat nil
  (interactive "<R>")
  (save-excursion
    (goto-char end)
    (set-mark (point))
    (goto-char beg)
    (condition-case nil
	(call-interactively #'anzu-query-replace-regexp)
      (t (deactivate-mark)))))
#+end_src

- get feedback when ~query-replacing~ (since we don't use evil's ~:s/~, but instead emac's native ~query-replace-regexp~)
#+begin_src elisp
(global-anzu-mode)
(define-key! [remap query-replace] #'anzu-query-replace)
(define-key! [remap query-replace-regexp] #'anzu-query-replace-regexp)
#+end_src

*** no visual selections
- efficiency :: after spending considerable amounts of time using emacs with ~viper-mode~ (~vi~ has no visual selections), i came to the conclusion that using ~visual-mode~ in ~vim~ actually encourages less efficient behaviour (manually selecting text even though a motion would have been more efficient).
- motions :: we are faster & more efficient enforcing the usage of motions, prefix-number commands and ~evil-repeat~.  instead of visual line mode, use a number prefix argument like ~3dj, 3yap, 3ck~.  if we can't use a textobject (eg: braces, word, paragraph, sentence...).  just use ~<operator>~ + ~incsearch~ to act upto the position that we want.  (eg: ~d /~)
- viper-mode compatibility :: additionally it comes with the benefit of making our workflow more compatible if we are working on a different setup without doom, and only vanilla emacs+viper-mode (or just ~vi~ on a server) is available.
- emergency :: if all fails and we must use a visual selection, we may still use [[kbd:][C-space]] (emacs binding).
- paste replace :: to replace some text with yanked text (normally we would visually select that region (again, unefficient) and then paste over it).  we can use these equally efficient methods:
  a. delete the content and then use =yank-register=: ~"0p~ to paste
  b. use ~"_d~ to delete using the =null-register= and the paste normally.
  c. delete, paste, then use [[kbd:][C-p]] to cycle the kill ring back to the yanked text.
- ~evil-visual-block~ :: still enabled, since this is still a efficient gap bridger between editin multiple lines before switching to macros.

#+begin_src elisp
(define-key! [remap evil-visual-char] #'ignore)
(define-key! [remap evil-visual-line] #'ignore)
#+end_src

*** surround
- s/S :: vim's ~s, S~ is useless, since they are duplicates of: ~x, C~.  we introduce ~evil-surround~ operator.  it is very powerful, we always delete/add on surrounding pairs.  it directly extends evil's text editing workflow.
  - readme: https://github.com/emacs-evil/evil-surround
#+begin_src elisp
(map! :after evil
      :n "s" #'evil-surround-region
      :n "S" #'evil-Surround-region)

(after! evil-surround
  (add-to-list 'evil-surround-pairs-alist '(?` . ("`" . "`")))

  (add-hook! 'org-mode-hook :local
    (add-to-list 'evil-surround-pairs-alist '(?~ . ("~" . "~")))))
#+end_src

*** smartparens
#+begin_src elisp
(after! smartparens
  (setq sp-ignore-modes-list '()) ;; disable nowhere (consistency!)
  (->> (sp-local-pair "~" "~")
   (sp-with-modes 'org-mode)))
#+end_src

*** lispy(ville): editing lisp in vim
- makes vim's motions dwim in lisp modes (mainly respecting parenthesis).
- key-themes :: give me all the lispyville editing power but only the ones consistent with evil's modal editing.  which means not enabling [[kbd:][M-]] key-bindings ([[kbd:][M-]] is reserved for WM).
#+begin_src elisp
(add-hook! '(emacs-lisp-mode-hook
	     lisp-mode-hook
	     clojure-mode-hook
	     cider-repl-mode-hook)
	   #'lispyville-mode)

;; call help on `lispyville-set-key-theme' to see what is bound.
(after! lispyville
  (lispyville-set-key-theme '(operators
                              insert
                              c-w
                              c-u
                              prettify
                              text-objects
                              commentary
                              slurp/barf-lispy)))
#+end_src

some selective mappings of disabled keythemes
- [[kbd:][H]] :: "up"
- [[kbd:][()]] :: navigate to beginning/end of current sexp.  very useful! (structural navigation, eg. insert at end of current sexp)
#+begin_src elisp
(map! :map lispyville-mode-map :after lispyville
      :nm "H" #'lispyville-raise-list

      :nm "(" #'lispyville-backward-up-list
      :nm ")" #'lispyville-up-list)
#+end_src

** global marks
- when in a codebase/project, of no matter what size, this is the msot efficient way of navgating the files/buffers one finds themselves alternating between.  this is for when ~switch-to-buffer~, and fuzzy-finding are just too many keystrokes and repetetively used and ~evil-switch-to-windows-last-buffer~ just isn't enough, since we need to alternate between more than 2 buffers.
- ~evil-set-mark~ on a file with evil's global-marks (UPPERCASE), and then jump back and forth between them.
- we remap ~evil-goto-mark~ since you should use ~evil-goto-mark-line~ instead anyways.
- we override ~evil-goto-mark-line~ binding, since it is redundant: for buffer-local marks, use ~evil-goto-mark~ binding instead.
- usage example :: mark buffers: {source-files-xzy, compilation, manpage/devdocs, REPL} each mnemonically to their first letters.
#+begin_src elisp
(defun u/global-mark-goto (char)
  "go to the marker buffer specified by CHAR.

this differs from `evil-goto-mark' in that it only goes to the marked buffer (not also the point in the buffer where the mark was set).  we use global marks to goto specific buffers.

(for ergonomics and speed we upcase the input char automatically.  (but to set the mark, you must still use UPPERCASE)."

  (interactive (list (read-char)))
  (let ((char (upcase char))
	(marker (evil-get-marker char)))

    (cond ((markerp marker) (switch-to-buffer (marker-buffer marker)))
	  ((consp marker) (find-file (car marker)))
	  ((numberp marker) (message "[global-mark] mark '%s' set in current buffer" mark-char))
	  ((user-error "[global-mark] '%c' is not set" char)))))

(map! :map 'override
      :nm "'" #'u/global-mark-goto)
#+end_src

- make evil's global markers persist across sessions (save state => reduce repetition, increase consistency).  this is default behaviour in vim.
#+begin_src elisp
(after! savehist
  (add-to-list 'savehist-additional-variables 'evil-markers-alist)

  (add-hook! 'savehist-save-hook
    (kill-local-variable 'evil-markers-alist)
    (dolist (entry evil-markers-alist)
      (when (->> (cdr entry)
		 markerp)
	(setcdr entry
		(cons (->> entry
			   cdr
			   marker-buffer
			   buffer-file-name
			   file-truename)
		      (->> entry
			   cdr
			   marker-position))))))

  (add-hook! 'savehist-mode-hook
    (setq-default evil-markers-alist evil-markers-alist)
    (kill-local-variable 'evil-markers-alist)
    (make-local-variable 'evil-markers-alist)))
#+end_src

*** a note on package: harpoon
we have no need don't for a package like harpoon, since it implements its own backend for switching buffers instead of leveraging emacs/evil native and already implemented marks.  this functionality was enven already available in vi, by just recording: ~:b buffer-x~ into register ~x~, and then subsequently using ~@x~ to jump to that buffer from anywhere with minimal keystrokes.
marks are even more powerful, as they allow you to mark any buffer.  and if you desire to save them, save them in a ~.dir-locals~ file in the projects root, and load them explicitly when you reopen the project.

* occur: emacs interactive grep
- occur :: use it like grep, to compactly view only maching lines.  additionally it is a powerful interactive search & replace tool.  (edit the matching lines buffer interactively, for more power combined the editing using macros).
#+begin_src elisp
(map! :map occur-mode-map :after replace
      :n "q" #'quit-window) ;; consistent with other read-only modes (magit, dired, docs...)

(map! :after evil
      :nm "g/"  #'occur)
#+end_src

* dired
- filemanagers :: avoid using integrated filemanagers (such as dired / ranger / lf) whenever possible replace them with shell commands and fuzzy-finding (in project/root/recentfiles)
- in most cases it is more extensible and faster using tools such as emacs find-file in combination with fuzzy finding and using global bookmarks for frequently used projects/files.
- create new files/dir's using ~find-file~ instead of ~dired-create-empty-file~ (inserts filetemplate properly)
- if we think we need a sidebar type file explorer, we are doing something terribly inefficient in our workflow.
- use a fileexplorer mostly for getting an overview of a directory and to manipulate files in that directory.
- it's more efficient, faster and extensible using search & completion tools, such as emacs: find-file, fuzzy finding, global-marks and bookmarks for switching to other directories and files.
- ditch spamming [[kbd:hjkl][hjkl]] to navigate nested directories fore directly goto to the file we are looking for.
- hide details & hidden files by default (visual distracting clutter).  show details explicitly if needed.

#+begin_src elisp
(after! dired
#+end_src

#+begin_src elisp
(add-hook! 'dired-mode-hook #'dired-hide-details-mode)

(add-hook! 'wdired-mode-hook (dired-hide-details-mode -1)) ;; prevent hidden edits

(map! :map dired-mode-map :localleader :after dired-x
      :desc "dired-hide-details" "h" (cmd! (->> '(dired-omit-mode
						  dired-hide-details-mode)
						(mapc #'call-interactively))))

;; open graphical files externally
(setq dired-open-extensions (->> '((("mkv" "webm" "mp4" "mp3") "mpv")
				   (("pdf") "zathura")
				   (("gif" "jpg" "png") "feh")
				   (("docx" "odt" "odf") "libreoffice"))

			     (-mapcat (-lambda ((extensions app))
					(->> extensions
					     (--map (cons it app))))))
      dired-recursive-copies 'always
      dired-recursive-deletes 'always
      dired-no-confirm '(uncompress move copy)
      dired-omit-files "^\\..*$")

(map! :map dired-mode-map :after dired
      :m "h" #'dired-up-directory) ;; HACK :: must be 'm' (otherwise also binds in 'wdired-mode')

;; try dired-open fn's (no success => call: `dired-find-file')
(define-key! [remap dired-find-file] #'dired-open-file)
#+end_src

** archive file
- archive all things that were once written or created (instead of deleting them) => digital content cost's little to no space.  and one shall be grateful later in life to have recorded data (that can be analyzed & crunched) what one was thinking.
- this ensures a predictable and consistent archiving scheme (archive to original path under archive)
#+begin_src elisp
(defvar u/archive-dir "~/Archive")

(defun u/dired-archive ()
  "`mv' marked file/s to: `u/archive-dir'/{relative-filepath-to-HOME}/{filename}"
  (interactive)

  (->> (dired-get-marked-files nil nil)
       (mapc (lambda (file)
          (let* ((dest (file-name-concat
			u/archive-dir
			(concat
			 (->> "~/"
			      (file-relative-name file)
			      file-name-sans-extension)

			 "_archived_"
			 (format-time-string "%F_T%H-%M-%S")
			 (when (file-name-extension file)
			   (->> file
				file-name-extension
				(concat "."))))))

                 (dir (file-name-directory dest)))

            (unless (file-exists-p dir)
              (make-directory dir t))
            (rename-file file dest 1)))))

  (revert-buffer))

(map! :map dired-mode-map :localleader :after dired
      "a" #'u/dired-archive)
#+end_src

#+begin_src elisp
)
#+end_src

* org
 - syntax :: for lists, be consistent and only use: ~-~ for unordered lists (never ~*, +~), and for ordered lists, use ~1.~, ~a.~ (never ~1)~ or ~a)~)
 - ui ::
   - ensure all headings and faces have the same heigth => better overview & less overhead
   - visually distinctualize headings & keywods from the rest of the text with coloring and bold
   - like in code, everything is code/data => also org mode / latex documents.
   - its not about some fancy looking thing, its about the internals, the quality of the data, not the presentation.
- we don't hard format (using ~evil-fill~) long lines in prose (~org-mode~).  since it makes sense for the content (eg. a long org list item) to be coherent as a single block of text.  we use ~visual-fill-column~ to display lines right.

#+begin_src elisp
(after! org
#+end_src

** tags
- Always use tags to specify what a todo-item belongs to & never write it in the todo-name | not: ~TODO uni math assignment [2]~ => instead: ~TODO assignment [2] :uni:math:assignments:~
- use tags with path hierarchy & inheritance to signal to which project / topic / subject the task belongs to have a clear overview in the agenda.
  - use the tags from more general -> specific (eg: ~:fitness:endurance:running:ultrarunning:~, only use more specific tags if the note actually specifically talks about them, otherwise use the more general one)
- mark top level subject with tag
- ex: ~:cs:math:statisticts:exercise~ => filter: outstanding ~exercises~ of math.
- ex: ~:cs:math:statisticts:question:~ => filter: outstanding ~questions~
- ex: ~:personal:youtube:video~
- ex: ~:personal:book:fiction~
- ex: ~- [ ] change keybindings :config:emacs:~
- never mention the location/project of the task, instead specify it as a task hierarchy (scope resolution, flexible querying) (same as in programming var-names should never include the typee / functions don't have module-name in their name, instead the location is specified via module)
- ~[ ] fix bugs in emacs config for the org mode module~ => ~[ ] fix bugs :config:emacs:org:~
- this is a clear and highly structured, data orientated approach.  (all the benefits of data follow: querying, extensibility...)
- org-agenda :: filter for all headings with that specific tag across all files (eg.  sort class specific todos w tags)

** options
- archive all done tasks in current file/headings with org-agenda bulk action.
- each file gets its own entry in ~~/archive/org~
#+begin_src elisp
(add-hook! 'org-mode-hook '(visual-line-mode
                            org-fragtog-mode
                            rainbow-mode
                            laas-mode
                            +org-pretty-mode
                            org-appear-mode))

(setq-hook! 'org-mode-hook warning-minimum-level :error) ;; prevent frequent popups of *warning* buffer

(setq org-use-property-inheritance t
      org-reverse-note-order t ;; like stack
      org-startup-with-latex-preview nil
      org-startup-with-inline-images t
      org-startup-indented t
      org-startup-numerated t
      org-startup-align-all-tables t
      org-list-allow-alphabetical t ;; alphabetical are useful for lists without ordering if you later want to reference an item (like case (a), case (b).)
      org-tags-column 0		    ;; don't align tags
      org-fold-catch-invisible-edits 'smart
      org-refile-use-outline-path 'full-file-path
      org-refile-allow-creating-parent-nodes 'confirm
      org-use-sub-superscripts '{}
      org-fontify-quote-and-verse-blocks t
      org-fontify-whole-block-delimiter-line t
      doom-themes-org-fontify-special-tags t
      org-num-max-level 3 ;; don't nest deeply
      org-hide-leading-stars t
      org-appear-autoemphasis t
      org-appear-autosubmarkers t
      org-appear-autolinks t
      org-appear-autoentities t
      org-appear-autokeywords t
      org-appear-inside-latex nil
      org-hide-emphasis-markers t
      org-pretty-entities t
      org-pretty-entities-include-sub-superscripts t
      org-list-demote-modify-bullet '(("-" . "-")
				      ("1." . "1."))
      org-blank-before-new-entry '((heading . nil)
				   (plain-list-item . nil))
      org-src-ask-before-returning-to-edit-buffer nil) ;; don't annoy me
#+end_src

#+begin_src elisp
(defadvice! u/insert-newline-above (fn &rest args)
  "pad newly inserted heading with newline unless is todo-item.

since i often have todolists , where i don't want the newlines.  newlines are for headings that have a body of text."
  :after #'+org/insert-item-below
  (when (and (org-at-heading-p)
             (not (org-entry-is-todo-p)))
    (+evil/insert-newline-above 1)))

(defadvice! u/insert-newline-below (fn &rest args)
  :after #'+org/insert-item-above
  (when (and (org-at-heading-p)
             (not (org-entry-is-todo-p)))
    (+evil/insert-newline-below 1)))
#+end_src

** symbols
- clean up symbols with corresponding coherent unicode symbols.
- use ~●~ for heading, ~─~ for list for unambiguity and a minimalist look.  org heading level is differentiated by indentation and face.
#+begin_src elisp
(add-hook! 'org-mode-hook '(org-superstar-mode
			    prettify-symbols-mode))

(setq org-superstar-headline-bullets-list "●")

(setq org-superstar-item-bullet-alist '((?- . "─")
                                        (?* . "─")
                                        (?+ . "⇒")))

(appendq! +ligatures-extra-symbols '(:em_dash       "—"
                                     :ellipses      "…"
                                     :arrow_right   "→"
                                     :arrow_left    "←"
                                     :arrow_lr      "↔"))

(add-hook! 'org-mode-hook
  (appendq! prettify-symbols-alist '(("--" . "–")
				     ("---" . "—")
				     ("->" . "→")
				     ("=>" . "⇒")
				     ("<=>" . "⇔"))))
#+end_src

** org/keybindings
#+begin_src elisp
(map! :map org-mode-map :after org
      :localleader
      "\\" #'org-latex-preview
      "z"  #'org-add-note
      :desc "toggle-checkbox" "["  (cmd! (let ((current-prefix-arg 4))
                                           (call-interactively #'org-toggle-checkbox))))
#+end_src

** babel
#+begin_src elisp
(setq org-babel-default-header-args '((:session  . "none")
				      (:results  . "replace")
				      (:exports  . "code")
				      (:cache    . "no")
				      (:noweb    . "yes")
				      (:hlines   . "no")
				      (:tangle   . "no")
				      (:mkdirp   . "yes")
				      (:comments . "link"))) ;; important for when wanting to retangle
#+end_src

** clock
#+begin_src elisp
(setq org-clock-out-when-done t
      org-clock-persist t
      org-clock-into-drawer t)
#+end_src

** task states
- these are task states are used for personal daily organization & studying at university (keeping track of lectures, assignments, events)
- using symbols instead of words to represent states => less clutter, more concise, readeable & structured.
- order them with priorities to assign order of execution if there are many tasks
- when changing state add a note to the state-change if needed
- use ~org-add-note~ for leaving comments on the article.  (eg: thougths when revisiting the article at a later time.)
- reflecting
- log/track
- progress
- time
- performance
- stats
- steps taken to complete task
- reason: why task was moved to that state
- seamlessly pick up work at a later time
- ~[ ] watch lecture~ -> ~[-] watch lecture~ | annotate time: where the task was last left off: "01:25:23h"

~[@]~: event
- useful if we have to take steps after the event

~[ ]~: outstanding item

~[?]~: optional
- non-compulsory item

~[-]~: in-progress / started
- item being worked on

~[=]~: on-hold
- unfinished item waiting for smthing, before can be finished / continued

~[&]~: review
- review item (ex: correct assignment, revise meeting notes).
- post completion: review performance, asess effort...

~[>]~: delegated/assigned to someone
- waiting for it to be finished to resume
- check up on them

~[\]~: cancelled
  - no longer neccessary

~[x]~: completed

we prompt for a note on the task when chaning state to either: on-hold, in-prog or delegated, since we want to leave a comment on how work should be resumed next time the task is being revisited (eg. page number of a book, who to check in with after delegating the task, exercise that is to be worked on)
#+begin_src elisp
;; ! => save timestamp on statchange
;; @ => save timestamp on statchange & add note associated with change to LOG.
(setq org-todo-keywords '((sequence
                           "[ ](t)"
                           "[@](e)"
                           "[?](?!)"
                           "[-](-@)"
                           "[>](>@)"
                           "[=](=@)"
                           "[&](&@)"
                           "|"
                           "[x](x!)"
                           "[\\](\\!)")))

(setq org-todo-keyword-faces '(("[@]" . (bold +org-todo-project))
			       ("[ ]" . (bold org-todo))
			       ("[-]" . (bold +org-todo-active))
			       ("[>]" . (bold +org-todo-onhold))
			       ("[?]" . (bold +org-todo-onhold))
			       ("[=]" . (bold +org-todo-onhold))
			       ("[&]" . (bold +org-todo-onhold))
			       ("[\\]" . (bold org-done))
			       ("[x]" . (bold org-done))))
#+end_src

- Log to drawer: ~LOG~
- Make org-log messages more data orientated and functional.  (less verbose and literate, easier to parse)
#+begin_src elisp
(setq org-log-done 'time
	org-log-repeat 'time
	org-todo-repeat-to-state "[ ]"
	org-log-redeadline 'time
	org-log-reschedule 'time
	org-log-into-drawer "LOG") ;; more concise & modern than: LOGBOOK

(setq org-priority-highest 1
	org-priority-lowest 3)

(setq org-log-note-headings '((done . "note-done: %t")
			      (state . "state: %-3S -> %-3s %t") ;; NOTE :: the custom task-statuses are all 3- wide
			      (note . "note: %t")
			      (reschedule . "reschedule: %S, %t")
			      (delschedule . "noschedule: %S, %t")
			      (redeadline . "deadline: %S, %t")
			      (deldeadline . "nodeadline: %S, %t")
			      (refile . "refile: %t")
			      (clock-out . "")))
#+end_src

** capture templates
- create capture-templates for organization on a per project basis, ex: university, personal, work..
- capture templates are used to collect & capture notes, events, tasks and templates; structured, tagged, sorted into a specific files.
- this ensures information based data is consistently captured.
- this is very customizeable and allows us to setup complex templates and should be used whenever we want to log data / repeatatively track things, or want to capture structured data with different entries consistently (eg: literature to track reading process).
- use the heading: ~inbox~ for collecting the captured tasks => can get messy, and can be refactored out of inbox into more structure if neccessary.
- for each project there is a separate folder (relative to org-dir) with files:
- agenda :: all tasks (todos, completed etc) and events (physical appointments)
- notes :: thoughts, exploration -> to study, to remember, to refactor
- set tags for entire file in the document-header with ~#+filetags: :proj:~
- motivation :: this scheme of =agenda/notes= is used to have a structured and consistent approach for generic projects-management.
- prepending :: if recent item's are of higher relevance
- appending :: for hierarchical order eg. book-quotes ordered from begin -> end

#+begin_src elisp

(defvar u/doct-documents-dir "~/Documents")

(setq org-directory (file-name-concat u/doct-documents-dir "org"))

(defvar u/doct-journal-dir (file-name-concat u/doct-documents-dir "journal")
  "daily captured journal files")

(defvar u/doct-literature-dir (file-name-concat u/doct-documents-dir "literature")
  "where to save literature sources, captured notes.")

(defvar u/doct-wiki-dir (file-name-concat u/doct-documents-dir "wiki")
  "personal knowledge base directory :: cohesive, structured, standalone articles/guides.
(blueprints and additions to these articles are captured into 'org-directory/personal/notes.org',
and the later reviewed and merged into the corresponding article of the wiki.")

(defvar u/doct-personal-dir (file-name-concat u/doct-documents-dir "personal")
  "none of anybody's business, except mine")

(defvar u/doct-uni-dir (file-name-concat u/doct-documents-dir "uni/cs/s3"))

(defvar u/doct-dotfiles-dir "~/Dotfiles")

(defun u/doct-journal-file (&optional time)
  "returns a structured filename based on the current date.
eg: journal_2024-11-03.org
TIME :: time in day of note to return. (default: today)"
  (->> (current-time)
       (or time)
       (format-time-string "%F")
       (format "journal_%s.org")
       (file-name-concat u/doct-journal-dir)))

(defun u/doct-agenda-file (project-dir)
  (file-name-concat project-dir "org" "agenda.org"))

(defun u/doct-notes-file (project-dir)
  (file-name-concat project-dir "org" "notes.org"))

(defun u/doct-task-template (project-dir)
  `("task"
    :keys "t"
    :file ,(u/doct-agenda-file project-dir)
    :headline "inbox"
    :prepend t
    :empty-lines-after 1
    :template ("* [ ] %^{title}%?")))

(defun u/doct-event-template (project-dir)
  `("event"
    :keys "e"
    :file ,(u/doct-agenda-file project-dir)
    :headline "events"
    :prepend t
    :empty-lines-after 1

    :template ("* [@] %^{title}%?"
               "%^T"
               ":PROPERTIES:"
               ":REPEAT_TO_STATE: [@]" ; NOTE :: in case is made repeating
               ":location: %^{location}"
               ":material: %^{material}"
               ":END:")))

(defun u/doct-note-template (project-dir)
  `("note"
    :keys "n"
    :file ,(u/doct-notes-file project-dir)
    :prepend t
    :empty-lines-after 1

    :template ("* %^{title} %^g"
               ":PROPERTIES:"
               ":created: %U"
               ":END:"
               "%?")))

(defun u/doct-cc-src-template (project-dir)
  "for quickly implementing/testing ideas (like a scratchpad, but have all
  our code-snippets in a single literate document, instead of creating a new file each time).  choose either c or c++."
  `("src: c/c++"
    :keys "s"
    :file ,(u/doct-notes-file project-dir)
    :prepend t
    :empty-lines 1
    :template ("* %^{title} :%^{lang|C|C|cpp}:"
               ":PROPERTIES:"
               ":created: %U"
               ":END:"
               "#+begin_src %\\2"
               "int main() {"
               "        %?"
               "}"
               "#+end_src")))

(defun u/doct-expand-templates (project-dir template-fns)
  (->> template-fns
       (--map (apply it (list project-dir)))))

(setq org-capture-templates
      (doct
       `(("uni"
	  :keys "u"
	  :children ,(->> '("nm" "spca" "an2" "ti")
			  (-map (lambda (name)
				  (let* ((dir (file-name-concat u/doct-uni-dir name))
					 (key (substring name 0 1))
					 (templates (append '(u/doct-task-template
							      u/doct-event-template
							      u/doct-note-template)
							    (when (member name '("spca" "nm"))
							      '(u/doct-cc-src-template)))))

				    (list name
					  :keys key
					  :children (u/doct-expand-templates dir templates)))))))

	 ("personal"
	  :keys "p"
	  :children ,(u/doct-expand-templates u/doct-personal-dir
					      '(u/doct-task-template
						u/doct-event-template
						u/doct-note-template)))

	 ("wiki"
	  :keys "w"
	  :children ,(u/doct-expand-templates u/doct-wiki-dir
					      '(u/doct-task-template
						u/doct-note-template)))

	 ("dotfiles"
	  :keys "d"
	  :children ,(u/doct-expand-templates u/doct-dotfiles-dir
					      '(u/doct-task-template
						u/doct-note-template)))

	 ("journal"
	  :keys "j"
	  :file (lambda () (u/doct-journal-file))

	  :title (lambda ()
		   (->> (format-time-string "journal: %A, %e. %B %Y")
			downcase))

	  :children (("journal init"
		      :keys "j"
		      :type plain
		      :template  ("#+title:  %{title}"
				  "#+author: %(user-full-name)"
				  "#+email:  %(message-user-mail-address)"
				  "#+date:   %<%F>"
				  "#+filetags: :journal:"
				  ""
				  "* goals"
				  "- [ ] %?"
				  ""
				  "* agenda"
				  "** [ ] "
				  ""
				  "* notes"))

		     ("note"
		      :keys "n"
		      :headline "notes"
		      :prepend t
		      :empty-lines-after 1
		      :template ("* %^{title}"
				 ":PROPERTIES:"
				 ":created: %U"
				 ":END:"
				 "%?"))

		     ("yesterday review"
		      :keys "y"
		      :unnarrowed t

		      :file (lambda ()
			      (->> (days-to-time 1)
				   (time-subtract (current-time))
				   u/doct-journal-file))

		      :template ("* gratitude"
				 "- %?"
				 ""
				 "* reflection"
				 "-"))))

	 ("literature"
	  :keys "l"

	  :file (lambda () (read-file-name "file: " (file-name-concat u/doct-literature-dir "notes/")))

	  :children (("add to readlist"
		      :keys "a"
		      :file ,(file-name-concat u/doct-literature-dir "readlist.org")
		      :headline "inbox"
		      :prepend t
		      :template ("* [ ] %^{title}"))

		     ("init source"
		      :keys "i"

		      :file (lambda ()
			      (->> (concat (->> (read-from-minibuffer "short title: ")
						(replace-regexp-in-string " " "_"))
					   ".org")
				   (file-name-concat (file-name-concat u/doct-literature-dir "notes/"))))

		      :type plain

		      :template ("#+title:  %^{full title}"
				 "#+author: %(user-full-name)"
				 "#+email:  %(message-user-mail-address)"
				 "#+date:   %<%F>"
				 "#+filetags: :literature:%^g"
				 ""
				 "* [-] %\\1%?"
				 ":PROPERTIES:"
				 ":title:  %\\1"
				 ":author: %^{author}"
				 ":year:   %^{year}"
				 ":type:   %^{type|book|book|textbook|book|paper|article|audiobook|podcast}"
				 ":pages:  %^{pages}"
				 ":END:")

		      :hook (lambda () (message "change task-state in readlist.org!")))

		     ("quote"
		      :keys "q"
		      :headline "quotes"
		      :empty-lines-before 1

		      :template ("* %^{title} [pg: %^{page}]"
				 ":PROPERTIES:"
				 ":created: %U"
				 ":END:"
				 "#+begin_quote"
				 "%?"
				 "#+end_quote"))

		     ("note: literary"
		      :keys "l"
		      :headline "literature notes"
		      :empty-lines-before 1
		      :template ("* %^{title} [pg: %^{page}] %^g"
				 ":PROPERTIES:"
				 ":created: %U"
				 ":END:"
				 "%?"))

		     ("note: transient"
		      :keys "t"
		      :headline "transient notes"
		      :empty-lines-before 1
		      :template ("* %^{title} %^g"
				 ":PROPERTIES:"
				 ":created: %U"
				 ":END:"
				 "%?"))

		     ("summarize"
		      :keys "s"
		      :headline "summary"
		      :unnarrowed t
		      :type plain
		      :template ("%?")
		      ;; reminder to log finishing date
		      :hook (lambda ()
			      (message "change task-state!: TODO -> DONE"))))))))
#+end_src

** agenda
- multi-day-todo-events: add multiple timestamps on the same line => same task shows scheduled on different days.  ex:
- track which university lectures have been watched & reviewed.  => even if they are spread out onto multiple days => log all completions / review-notes under the same task.

#+begin_src elisp
(add-hook! 'org-agenda-mode-hook #'org-super-agenda-mode)

(defvar u/archive-dir "~/Archive")
;; NOTE :: archive based on relative file path
(setq org-archive-location (file-name-concat u/archive-dir
					     "org"
					     "%s::")
      org-agenda-skip-scheduled-if-done t
      ;; org-agenda-sticky t
      org-agenda-skip-deadline-if-done t
      org-agenda-include-deadlines t
      org-agenda-tags-column 0
      org-agenda-block-separator ?─
      org-agenda-breadcrumbs-separator "…"
      org-agenda-compact-blocks nil
      org-agenda-show-future-repeats nil
      org-deadline-warning-days 3
      org-agenda-time-grid nil
      org-capture-use-agenda-date t)
#+end_src

- agenda files :: we only ever use [[*capture templates][capture templates]] to track tasks/events that should show up in the agenda-view.
#+begin_src elisp
(defun u/agenda-last-journal-files ()
  "include tasks from {today's, yesterday's} journal's agenda "
  (->> (days-to-time 1)
       (time-subtract (current-time))
       u/doct-journal-file
       (list (u/doct-journal-file))))

(setq org-agenda-files
      (->> (u/agenda-last-journal-files)
	   (append (->> (list u/doct-personal-dir
			      u/doct-uni-dir
			      u/doct-dotfiles-dir)
		    (--map (when (file-exists-p it)
			     (directory-files-recursively it ".*agenda.org"))))) ;; see: u/doct-agenda-file
	   (remove nil)))
#+end_src

#+begin_src elisp
(defadvice! u/add-newline (fn &rest args)
  "Separate dates in 'org-agenda' with newline."
  :around #'org-agenda-format-date-aligned
  (->> (apply fn args)
       (concat "\n")))
#+end_src

org-agenda by default is a clusterfuck.  this will clean it up: cleanly align everything into columns & group items.
+ achieve a nce and consistent readeable data-orinetated view
+ all task-states have the same length, otherwise there is no task-keyword alignment.
+ Set more concise & informing ~deadline~ & ~scheduled~ strings
#+begin_src elisp
(setq org-agenda-todo-keyword-format "%-3s"
      org-agenda-scheduled-leaders '("" "<< %1dd")

      org-agenda-deadline-leaders '("─────"
				    ">> %1dd"
				    "<< %1dd")

      org-agenda-prefix-format '((agenda . "%-20c%-7s%-7t") ;; all columns separated by minimum 2 spaces
				 (todo   . "%-20c%-7s%-7t")
				 (tags   . "%-20c%-7s%-7t")
				 (search . "%-20c%-7s%-7t")))
#+end_src

** org roam
#+begin_src elisp
(setq org-roam-directory u/doct-wiki-dir)
#+end_src

#+begin_src elisp
)
#+end_src

* dictionary
#+begin_src elisp
(after! dictionary
  (setq dictionary-server "dict.org"
        dictionary-default-dictionary "*"))
#+end_src

* devdocs
i always look up documentation/manuals within emacs.  (only if it's not sufficient do i resort to the browser/chatgpt)
#+begin_src elisp
(after! devdocs
  (setq devdocs-window-select t))

(setq-hook! 'java-mode-hook devdocs-current-docs '("openjdk~17"))
(setq-hook! 'c++-mode-hook devdocs-current-docs '("cpp" "eigen3"))
(setq-hook! 'c-mode-hook devdocs-current-docs '("c"))
(setq-hook! '(cider-mode-hook
	      cider-repl-mode-hook)
  devdocs-current-docs '("clojure~1.11"))
#+end_src

* whisper: transcription
we often formulate notes using transcription for speed and ergonomics.
always use ~evil-define-operator~ for ~evil-mode~ integration when defining routines to act on text.
#+begin_src elisp
(evil-define-operator u/reformat-prose (beg end)
  "we write all lowercase, all the time (to make the text more monotone, such that it's value will
speak more for it's self).  using the technical document convention of double space full stops for
legibility."
  (save-excursion
    (downcase-region beg end)
    (repunctuate-sentences t beg end)))

(add-hook! 'whisper-after-transcription-hook (u/reformat-prose (point-min) (point-max)))

(map! :leader "X" #'whisper-run)
#+end_src

* vertico: minibuffer completion
- we want a minimalist unobtrusive menu on the bottom of the frame, not a huge window popup disturbing our focus and workflow.
- it promotes finding items not by navigating via scrolling through candidates, but instead by searching.  we don't need a fancy popup everytime we want to switch to a candidate, we only want to know when the completion matches, since we already know beforehand what we are looking for.
- it is consistent with dmenu's appearance.
#+begin_src elisp
(vertico-flat-mode)
#+end_src

* nov: ebooks
- uses variable pitch mode (serif font for reading)
- ~visual-line-mode~ and ~visual-fill-column~ mode to wrap line & center text
- o, outline :: which is more mnemonic (consistent with pdf-view-mode, info-mode, evil: 'imenu' outline when in code)
- q :: consistent with other read-only modes (magit, dired, docs...)
- SPC :: don't override leader-mode-binding
- line-spacing :: padding increases focus on current line for long prose text.
- screen-context-lines :: no confusing page overlaps, always start reading on the first visible line of the next page
#+begin_src elisp
(use-package! nov
  :mode ("\\.epub\\'" . nov-mode)
  :config
  (setq nov-variable-pitch t
        nov-text-width t)
  (advice-add 'nov-render-title :override #'ignore) ;; using modeline...

  (map! :map (nov-mode-map nov-button-map)
        "SPC" nil
        :n "q" #'kill-current-buffer
        :n "o" #'nov-goto-toc

        ;; next/previous page
        :n "<next>" #'nov-scroll-up
        :n "<prior>" #'nov-scroll-down)

  (add-hook! 'nov-mode-hook
    (visual-fill-column-mode)
    (visual-line-mode)

    (setq-local next-screen-context-lines 0
                line-spacing 2)

    ;; HACK :: need to unset
    (setq-local global-hl-line-mode nil)
    (hl-line-mode -1)))
#+end_src

* autocomplete: corfu
autocomplete menu hidden by default.  we want recreational programming/writing to be focused, distractionless, and unobtrusive.
if neccessary we may request completion candidates explicitly.
- we don't want autocomplete to show up and distract us when we already know exactly what we are going to type (evil-abbrevs are still your friend here though).
- make use of it only when we don't know the exact symbol name / function signature, or when typing overly long symbol-names becomes tedious.
- this enforces more thoughtful programming, evaluating what the function actually does and let's us focus more on the semantics of the code.
- it actually makes us faster, since it removes the mental overhead and interruption that arises from the distracting autocomplete menu.  it has great impact on improving the overall typing speed.

- capf backends :: eg. completing a file: [[kbd:][C-x C-f]] like in vim.
- completion keybindings :: use [[kbd:][TAB]] to invoke autocompletion-menu/expand-snippet.  use [[kbd:][C-n/p]] for ~evil-complete~ (mostly [[kbd:][C-p]], since the abbrev is most likely behind the point) and navigating the completion candidates (consistent with ~evil~, minibuffer).

#+begin_src elisp
(after! corfu
  (setq corfu-auto-delay nil ;; never auto-activate (activated explicilty)
	corfu-preselect 'first)) ;; when activated, select first
#+end_src

- don't use doom's "smart" ~+corfu~ functions for [[kbd:][C-n/p]]. use evil's default abbrev functions, they are more accurate, fast & unobtrusive.
#+begin_src elisp
(define-key! [remap +corfu/dabbrev-or-last] #'evil-complete-previous)
(define-key! [remap +corfu/dabbrev-or-first] #'evil-complete-previous)
#+end_src

* file templates
in each new file systematically insert heading metadata (as comments) with the following template
- append more neccessary info if needed (ex: ~dependencies:~)
#+begin_example
# ---
# title:  file metadata
# author: emil lenz
# email:  emillenz@protonmail.com
# date:   [2024-01-06]
# info:
# - outlines file-metadata template, to be inserted at top of every file systematically.
# ---
#+end_example

- title :: full title of document.
- author :: document creator/"owner".
- email :: author's email
- for contacting him with question's / reaching out.
- date :: date of file creation, ISO8601 format.
- track our programming/writing progress over the years and just generally it is important to document the timing of things, to analyze/order/reconstruct them.
- info :: short document description/summary, think of it as a docstring for the file with this the reader should know what the document is about in one line.

we automate this repetetive task using a snippets.
#+begin_src elisp
(set-file-templates!
 '(org-mode :trigger "header")
 '(prog-mode :trigger "header")
 '(makefile-gmake-mode :ignore t))
#+end_src

* shell
- normal mode by default :: 99% of the time i want to navigate the compilation/shell buffer.  (and not read stdin in insert mode))
#+begin_src elisp
(setq shell-command-prompt-show-cwd t
      async-shell-command-buffer 'new-buffer)

(setq comint-process-echoes nil
      comint-input-ignoredups t)

(set-lookup-handlers! 'shell-mode :documentation '+sh-lookup-documentation-handler)

(add-to-list 'evil-normal-state-modes 'shell-mode)
#+end_src

* lsp (unused)
- when we kill buffer's, don't prompt to restart the server...
#+begin_src elisp
(after! lsp-mode
  (setq lsp-restart 'ignore))
#+end_src
